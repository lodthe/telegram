// Code generated by telegram-apigen. DO NOT EDIT.

package telegram

import "encoding/json"

type EditMessageTextRequest struct {
	// Optional. Required if inline_message_id is not specified. Unique identifier for
	// the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID string `json:"chat_id,omitempty"`

	// Optional. Required if inline_message_id is not specified. Identifier of the
	// message to edit
	MessageID int `json:"message_id,omitempty"`

	// Optional. Required if chat_id and message_id are not specified. Identifier of
	// the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`

	// New text of the message
	Text string `json:"text"`

	// Optional. Send Markdown or HTML, if you want Telegram apps to show bold, italic,
	// fixed-width text or inline URLs in your bot's message.
	ParseMode string `json:"parse_mode,omitempty"`

	// Optional. Disables link previews for links in this message
	DisableWebPagePreview bool `json:"disable_web_page_preview,omitempty"`

	// Optional. A JSON-serialized object for an inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// Use this method to edit text and game messages. On success, if edited message is
// sent by the bot, the edited Message is returned, otherwise True is returned.
func (b *Bot) EditMessageText(req *EditMessageTextRequest) (*Message, error) {
	j, err := b.makeRequest("editMessageText", req)
	if err != nil {
		return nil, err
	}

	var resp Message
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type EditMessageCaptionRequest struct {
	// Optional. Required if inline_message_id is not specified. Unique identifier for
	// the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID string `json:"chat_id,omitempty"`

	// Optional. Required if inline_message_id is not specified. Identifier of the
	// message to edit
	MessageID int `json:"message_id,omitempty"`

	// Optional. Required if chat_id and message_id are not specified. Identifier of
	// the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`

	// Optional. New caption of the message
	Caption string `json:"caption,omitempty"`

	// Optional. Send Markdown or HTML, if you want Telegram apps to show bold, italic,
	// fixed-width text or inline URLs in the media caption.
	ParseMode string `json:"parse_mode,omitempty"`

	// Optional. A JSON-serialized object for an inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// Use this method to edit captions of messages. On success, if edited message is
// sent by the bot, the edited Message is returned, otherwise True is returned.
func (b *Bot) EditMessageCaption(req *EditMessageCaptionRequest) (*Message, error) {
	j, err := b.makeRequest("editMessageCaption", req)
	if err != nil {
		return nil, err
	}

	var resp Message
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type EditMessageMediaRequest struct {
	// Optional. Required if inline_message_id is not specified. Unique identifier for
	// the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID string `json:"chat_id,omitempty"`

	// Optional. Required if inline_message_id is not specified. Identifier of the
	// message to edit
	MessageID int `json:"message_id,omitempty"`

	// Optional. Required if chat_id and message_id are not specified. Identifier of
	// the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`

	// A JSON-serialized object for a new media content of the message
	Media *InputMedia `json:"media"`

	// Optional. A JSON-serialized object for a new inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// Use this method to edit animation, audio, document, photo, or video messages. If
// a message is a part of a message album, then it can be edited only to a photo or
// a video. Otherwise, message type can be changed arbitrarily. When inline message
// is edited, new file can't be uploaded. Use previously uploaded file via its
// file_id or specify a URL. On success, if the edited message was sent by the bot,
// the edited Message is returned, otherwise True is returned.
func (b *Bot) EditMessageMedia(req *EditMessageMediaRequest) (*Message, error) {
	j, err := b.makeRequest("editMessageMedia", req)
	if err != nil {
		return nil, err
	}

	var resp Message
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type EditMessageReplyMarkupRequest struct {
	// Optional. Required if inline_message_id is not specified. Unique identifier for
	// the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID string `json:"chat_id,omitempty"`

	// Optional. Required if inline_message_id is not specified. Identifier of the
	// message to edit
	MessageID int `json:"message_id,omitempty"`

	// Optional. Required if chat_id and message_id are not specified. Identifier of
	// the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`

	// Optional. A JSON-serialized object for an inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// Use this method to edit only the reply markup of messages. On success, if edited
// message is sent by the bot, the edited Message is returned, otherwise True is
// returned.
func (b *Bot) EditMessageReplyMarkup(req *EditMessageReplyMarkupRequest) (*Message, error) {
	j, err := b.makeRequest("editMessageReplyMarkup", req)
	if err != nil {
		return nil, err
	}

	var resp Message
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type StopPollRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// Identifier of the original message with the poll
	MessageID int `json:"message_id"`

	// Optional. A JSON-serialized object for a new message inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// Use this method to stop a poll which was sent by the bot. On success, the
// stopped Poll with the final results is returned.
func (b *Bot) StopPoll(req *StopPollRequest) (*Poll, error) {
	j, err := b.makeRequest("stopPoll", req)
	if err != nil {
		return nil, err
	}

	var resp Poll
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type DeleteMessageRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// Identifier of the message to delete
	MessageID int `json:"message_id"`
}

// Use this method to delete a message, including service messages, with the
// following limitations:
// - A message can only be deleted if it was sent less than 48 hours ago.
// - Bots can delete outgoing messages in private chats, groups, and supergroups.
// - Bots can delete incoming messages in private chats.
// - Bots granted can_post_messages permissions can delete outgoing messages in
// channels.
// - If the bot is an administrator of a group, it can delete any message there.
// - If the bot has can_delete_messages permission in a supergroup or a channel, it
// can delete any message there.
// Returns True on success.
func (b *Bot) DeleteMessage(req *DeleteMessageRequest) (json.RawMessage, error) {
	return b.makeRequest("deleteMessage", req)
}
